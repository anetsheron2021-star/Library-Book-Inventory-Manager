# -*- coding: utf-8 -*-
"""Untitled23.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1muduEMC5CWQ6St8MBi8ucqpN6ZF8X8rk
"""

#!/usr/bin/env python3
"""
Library Book Inventory Manager
Single-file project for internship submission.

Features:
- Book and Library classes (OOP)
- Fast lookup using dicts (HashMap-like): books_by_id, ids_by_title, ids_by_author
- Add books (auto id), search by title/author (partial, case-insensitive)
- Issue / Return with simple validation and issued_date
- Persistence to 'library.json' and automatic load on startup
- Simple CLI menu for demonstration

Usage:
    python library_manager.py
"""

from __future__ import annotations
import json
from dataclasses import dataclass, asdict
from datetime import datetime
from pathlib import Path
from typing import Optional, Dict, Set, List

DATA_FILE = Path("library.json")


def _norm(s: str) -> str:
    """Normalize a string for indexing/searching (lowercase, stripped)."""
    return s.strip().lower()


@dataclass
class Book:
    """Dataclass representing a Book entity."""
    id: int
    title: str
    author: str
    year: Optional[int] = None
    isbn: Optional[str] = None
    issued_to: Optional[str] = None
    issued_date: Optional[str] = None  # ISO format

    def to_dict(self) -> Dict:
        return asdict(self)

    @staticmethod
    def from_dict(d: Dict) -> "Book":
        return Book(
            id=d["id"],
            title=d["title"],
            author=d["author"],
            year=d.get("year"),
            isbn=d.get("isbn"),
            issued_to=d.get("issued_to"),
            issued_date=d.get("issued_date"),
        )


class Library:
    """Library class managing books and indexes for fast search."""

    def __init__(self):
        # Main storage
        self.books_by_id: Dict[int, Book] = {}
        # Indexes for quick lookup
        self.ids_by_title: Dict[str, Set[int]] = {}
        self.ids_by_author: Dict[str, Set[int]] = {}
        # Next id to assign
        self._next_id = 1
        # Load existing data if present
        self.load()

    # ---------------- Index helpers ----------------
    def _index_book(self, book: Book) -> None:
        t = _norm(book.title)
        a = _norm(book.author)
        self.ids_by_title.setdefault(t, set()).add(book.id)
        self.ids_by_author.setdefault(a, set()).add(book.id)

    def _deindex_book(self, book: Book) -> None:
        t = _norm(book.title)
        a = _norm(book.author)
        if t in self.ids_by_title:
            self.ids_by_title[t].discard(book.id)
            if not self.ids_by_title[t]:
                del self.ids_by_title[t]
        if a in self.ids_by_author:
            self.ids_by_author[a].discard(book.id)
            if not self.ids_by_author[a]:
                del self.ids_by_author[a]

    def _ensure_next_id(self, candidate: int) -> None:
        if candidate >= self._next_id:
            self._next_id = candidate + 1

    # ---------------- CRUD operations ----------------
    def add_book(self, title: str, author: str, year: Optional[int] = None, isbn: Optional[str] = None) -> Book:
        """
        Add a new book and return it.
        Prints warning if ISBN already exists (doesn't block).
        """
        title = title.strip()
        author = author.strip()
        if isbn:
            for b in self.books_by_id.values():
                if b.isbn and b.isbn == isbn:
                    print(f"[warn] ISBN '{isbn}' already present in book id {b.id} ('{b.title}').")
                    break

        book = Book(id=self._next_id, title=title, author=author, year=year, isbn=isbn)
        self.books_by_id[book.id] = book
        self._index_book(book)
        self._ensure_next_id(book.id)
        self._next_id += 1
        self.save()
        return book

    def remove_book(self, book_id: int) -> bool:
        """Remove a book by ID. Returns True if removed; raises if issued."""
        book = self.books_by_id.get(book_id)
        if not book:
            return False
        if book.issued_to:
            raise ValueError("Cannot remove a book that is currently issued.")
        self._deindex_book(book)
        del self.books_by_id[book_id]
        self.save()
        return True

    def get_book(self, book_id: int) -> Optional[Book]:
        return self.books_by_id.get(book_id)

    # ---------------- Search operations ----------------
    def search_by_title(self, query: str) -> List[Book]:
        """Partial, case-insensitive search by title. Returns sorted list by id."""
        q = _norm(query)
        results: List[Book] = []
        # check indexed normalized title keys for substring match
        for title_key, idset in self.ids_by_title.items():
            if q in title_key:
                results.extend(self.books_by_id[i] for i in idset)
        # fallback: full-scan for any missed cases
        if not results:
            for b in self.books_by_id.values():
                if q in _norm(b.title):
                    results.append(b)
        return sorted(results, key=lambda b: b.id)

    def search_by_author(self, query: str) -> List[Book]:
        """Partial, case-insensitive search by author. Returns sorted list by id."""
        q = _norm(query)
        results: List[Book] = []
        for author_key, idset in self.ids_by_author.items():
            if q in author_key:
                results.extend(self.books_by_id[i] for i in idset)
        if not results:
            for b in self.books_by_id.values():
                if q in _norm(b.author):
                    results.append(b)
        return sorted(results, key=lambda b: b.id)

    # ---------------- Issue / Return ----------------
    def issue_book(self, book_id: int, issued_to: str) -> None:
        """
        Issue book to borrower. Raises ValueError on problems.
        Stores issued_date as UTC ISO string.
        """
        b = self.get_book(book_id)
        if not b:
            raise ValueError("Book not found.")
        if b.issued_to:
            raise ValueError("Book already issued.")
        b.issued_to = issued_to.strip()
        b.issued_date = datetime.utcnow().isoformat()
        self.save()

    def return_book(self, book_id: int) -> None:
        """Return a previously issued book. Raises ValueError if not issued or not found."""
        b = self.get_book(book_id)
        if not b:
            raise ValueError("Book not found.")
        if not b.issued_to:
            raise ValueError("Book is not issued.")
        b.issued_to = None
        b.issued_date = None
        self.save()

    # ---------------- Reports / utilities ----------------
    def total_books(self) -> int:
        return len(self.books_by_id)

    def issued_count(self) -> int:
        return sum(1 for b in self.books_by_id.values() if b.issued_to)

    def list_issued_books(self) -> List[Book]:
        return sorted((b for b in self.books_by_id.values() if b.issued_to), key=lambda b: b.id)

    def all_books(self) -> List[Book]:
        return sorted(self.books_by_id.values(), key=lambda b: b.id)

    def pretty_print_book(self, b: Book) -> str:
        issued = f"Issued to {b.issued_to} on {b.issued_date}" if b.issued_to else "Available"
        return f"[{b.id}] '{b.title}' by {b.author} ({b.year or 'n/a'}) ISBN:{b.isbn or 'n/a'} - {issued}"

    # ---------------- Persistence ----------------
    def save(self) -> None:
        """Save all library data to DATA_FILE."""
        payload = {
            "next_id": self._next_id,
            "books": [b.to_dict() for b in self.books_by_id.values()]
        }
        try:
            with DATA_FILE.open("w", encoding="utf-8") as f:
                json.dump(payload, f, ensure_ascii=False, indent=2)
        except Exception as e:
            print("[error] Failed to save data:", e)

    def load(self) -> None:
        """Load library data from DATA_FILE (if exists)."""
        if not DATA_FILE.exists():
            return
        try:
            with DATA_FILE.open("r", encoding="utf-8") as f:
                payload = json.load(f)
            books = payload.get("books", [])
            self.books_by_id.clear()
            self.ids_by_title.clear()
            self.ids_by_author.clear()
            for bd in books:
                b = Book.from_dict(bd)
                self.books_by_id[b.id] = b
                self._index_book(b)
                self._ensure_next_id(b.id)
            nid = payload.get("next_id")
            if isinstance(nid, int) and nid > self._next_id:
                self._next_id = nid
        except Exception as e:
            print("[error] Failed to load data:", e)


# ---------------- Small Interactive CLI ----------------
def _input_int(prompt: str) -> Optional[int]:
    s = input(prompt).strip()
    if not s:
        return None
    try:
        return int(s)
    except ValueError:
        print("[error] Please enter a valid integer.")
        return None


def cli_menu():
    lib = Library()

    # Seed demo books if empty (optional convenience)
    if lib.total_books() == 0:
        lib.add_book("The Hobbit", "J.R.R. Tolkien", year=1937, isbn="978-0618968633")
        lib.add_book("1984", "George Orwell", year=1949, isbn="978-0451524935")
        lib.add_book("Clean Code", "Robert C. Martin", year=2008, isbn="978-0132350884")

    while True:
        print("\n--- Library Menu ---")
        print("1. Add book")
        print("2. Search by title")
        print("3. Search by author")
        print("4. Issue book")
        print("5. Return book")
        print("6. Remove book")
        print("7. Show all books")
        print("8. Reports")
        print("9. Exit")
        choice = input("Choose an option [1-9]: ").strip()

        if choice == "1":
            title = input("Title: ").strip()
            author = input("Author: ").strip()
            year = _input_int("Year (optional): ")
            isbn = input("ISBN (optional): ").strip() or None
            if not title or not author:
                print("[error] Title and Author are required.")
                continue
            b = lib.add_book(title, author, year=year, isbn=isbn)
            print("[ok] Added:", lib.pretty_print_book(b))

        elif choice == "2":
            q = input("Search title (partial): ").strip()
            if not q:
                print("[error] Enter search term.")
                continue
            res = lib.search_by_title(q)
            if not res:
                print("No books found for that title.")
            else:
                for b in res:
                    print(" ", lib.pretty_print_book(b))

        elif choice == "3":
            q = input("Search author (partial): ").strip()
            if not q:
                print("[error] Enter search term.")
                continue
            res = lib.search_by_author(q)
            if not res:
                print("No books found for that author.")
            else:
                for b in res:
                    print(" ", lib.pretty_print_book(b))

        elif choice == "4":
            bid = _input_int("Book ID to issue: ")
            if not bid:
                continue
            borrower = input("Issued to (name or id): ").strip()
            if not borrower:
                print("[error] Borrower required.")
                continue
            try:
                lib.issue_book(bid, borrower)
                print("[ok] Book issued.")
            except Exception as e:
                print("[error]", e)

        elif choice == "5":
            bid = _input_int("Book ID to return: ")
            if not bid:
                continue
            try:
                lib.return_book(bid)
                print("[ok] Book returned.")
            except Exception as e:
                print("[error]", e)

        elif choice == "6":
            bid = _input_int("Book ID to remove: ")
            if not bid:
                continue
            try:
                removed = lib.remove_book(bid)
                if removed:
                    print("[ok] Book removed.")
                else:
                    print("[error] Book not found.")
            except Exception as e:
                print("[error]", e)

        elif choice == "7":
            books = lib.all_books()
            if not books:
                print("No books in library.")
            else:
                for b in books:
                    print(" ", lib.pretty_print_book(b))

        elif choice == "8":
            print("Total books:", lib.total_books())
            print("Issued count:", lib.issued_count())
            issued = lib.list_issued_books()
            if issued:
                print("Issued books:")
                for b in issued:
                    print(" ", lib.pretty_print_book(b))
            else:
                print("No books currently issued.")

        elif choice == "9":
            print("Exiting. Data saved to", DATA_FILE.resolve())
            break

        else:
            print("[error] Invalid choice, please pick 1-9.")


if __name__ == "__main__":
    cli_menu()